# Программа реализует алгоритм быстрой сортировки. Получает на вход n отрезков на прямой и m точек на прямой и для каждой точки выводит количество отрезков, которым принадлежит точка
# Вход: число n отрезков и число m точек (строка)
#       два числа - координаты левой и правой границы каждого отрезка (n строк)
#       m чисел - координаты m точек (строка)
# Выход: m чисел - количество отрезков которым принадлежит соответствующая точка, то есть число отрезков, которые точка пронизывает (строка)

# Тест вход:
# 2 3
# 0 5
# 7 10
# 1 6 11
# Тест выход:
# 1 0 0

#import bisect

# Функция разбиения массива на 3 части
def partition(uns_arr, l_e, r_e):                                                                           # получает несортированный массив и его границы
    medians = [[uns_arr[l_e], l_e], [uns_arr[(l_e + r_e) // 2], (l_e + r_e) // 2], [uns_arr[r_e], r_e]]     # берет из массива в список 3 элемента - левый, правый и средний (а также их индексы)
    medians.sort(key = lambda x: x[0])                                                                      # сортируем элементы по возрастанию
    op_x = medians[1][0]                                                                                    # берем средний из них в качестве опорного
    op_ind = medians[1][1]                                                                                  # и его индекс
    uns_arr[op_ind] = uns_arr[l_e]                                                                          # заменяем его не самый левый
    uns_arr[l_e] = op_x                                                                                     # заменяем самый левый на средний, ставим средний в начало
    j_c = l_e                                                                                               # счетчик позиции среднего элемента
    for i_c in range(l_e + 1, r_e + 1):                                                                     # перебираем все элементы (за исключением самого первого)
        if uns_arr[i_c] <= op_x:                                                                            # если значение очередного элемента меньше опорного
            j_c += 1                                                                                        # увеличиваем счетчик опорного
            save = uns_arr[j_c]                                                                             # сохраняем значение элемента с индексом счетчика
            uns_arr[j_c] = uns_arr[i_c]                                                                     # заменяем его на то меньшее значение, которое найдено в условии
            uns_arr[i_c] = save                                                                             # а то меньшее заменяем на значение элемента с индексом текущего счетчика
    uns_arr[l_e] = uns_arr[j_c]                                                                             # в качестве первого элемента ставим элемент с индексом текущего счетчика
    uns_arr[j_c] = op_x                                                                                     # а на элемент с индесом счетчика ставим опорный
    count_j = j_c                                                                                           # заводим еще один счетчик
    for i_c in range(j_c - 1, l_e - 1, -1):                                                                 # перебираем все элементы от опорного до самого первого
        if uns_arr[i_c] == op_x:                                                                            # если находим элемент, равный опорному
            count_j += -1                                                                                   # то сдвигаем его максимально вправо к предыдущему опорному элементу
            uns_arr[i_c] = uns_arr[count_j]
            uns_arr[count_j] = op_x
    return count_j, j_c                                                                                     # возвращаемые индексы - это границы подмассива с равными опорному элементами

# Функция быстрой сортировки
def quick_sort(unsort_arr, left_edge, right_edge):                                                          # получает на вход несортированный массив, а также его левую и правую границы
    if left_edge >= right_edge:                                                                             # если длина массива меньше 2 (то есть в нем 1 или 0 элементов)
        return                                                                                              # то не делаем ничего
    curr_pointer_left, curr_pointer_right = partition(unsort_arr, left_edge, right_edge)                    # выбираем опорный элемент, сортируем массив на 3 подмассива все элементы которых меньше, равны, или больше опорного. Возвращаем границы подмассива, элементы которого равны опорному
    quick_sort(unsort_arr, left_edge, curr_pointer_left - 1)                                                # применяем функцияю быстрой сортировки к массиву, все элементы которого меньше опорного
    quick_sort(unsort_arr, curr_pointer_right + 1, right_edge)                                              # применяем функцияю быстрой сортировки к массиву, все элементы которого больше опорного
    return

# Функция двоичного поиска, которая ищет, сколько элементов в отсортированном массиве меньше или равны заданного
# (фактически ищет границу между элементами: 1. которые меньше или равны, 2. которые больше)
def binary_search_less_eq(searched_array, searching_num, len_of_searched):      # на вход принимает сортированный массив, значение элемента и длину массива
    left_edge = 0                                                               # левая граница поиска
    right_edge = len_of_searched - 1                                            # правая граница поиска
    flag_find = False                                                           # флаг обнаружения совпадающего элемента
    while (left_edge <= right_edge):                                            # пока левая граница поиска меньше правой
        middle = left_edge + int((right_edge - left_edge) / 2)                  # находим середину
        if flag_find == False:                                                  # если совпадающий элемент еще не найден
            if searching_num == searched_array[middle]:                         # если элемент середины поиска является искомым
                left_edge = middle + 1                                          # безопасно сдвигаем левую границу
                flag_find = True                                                # поднимаем флаг
            else:
                if searching_num < searched_array[middle]:                  # иначе, если искомое число располагается слева от середины поиска (то есть меньше)
                    right_edge = middle - 1                                 # сдвигаем правую границу поиска
                else:                                                       # иначе, если искомое число располагается справа от середины поиска (то есть больше)
                    left_edge = middle + 1                                  # сдвигаем левую границу поиска
        else:                                               # если совпадающий элемент уже нашли ранее
            if searching_num == searched_array[middle]:     # если элемент текущей середины поиска является искомым
                left_edge = middle + 1                      # безопасно сдвигаем левую границу
            else:
                right_edge = middle - 1                     # безопасно сдвигаем правую границу
    return left_edge                                        # вылетим из цикла только тогда, когда левая граница будет больше правой (при этом она будет указывать на индекс элемента, который находится справа от последнего искомого (либо больше его))

# Функция двоичного поиска, которая ищет, сколько элементов в отсортированном массиве строго меньше заданного
# (фактически ищет границу между элементами: 1. которые меньше, 2. которые больше или равны)
def binary_search_less(searched_array, searching_num, len_of_searched): # на вход принимает сортированный массив, значение элемента и длину массива
    left_edge = 0                                                       # левая граница поиска
    right_edge = len_of_searched - 1                                    # правая граница поиска
    flag_find = False                                                   # флаг обнаружения совпадающего элемента
    while (left_edge <= right_edge):                                    # пока левая граница поиска меньше правой
        middle = left_edge + int((right_edge - left_edge) / 2)          # находим середину
        if flag_find == False:                                          # если совпадающий элемент еще не найден
            if searching_num == searched_array[middle]:                     # если элемент середины поиска является искомым
                right_edge = middle - 1                                     # безопасно сдвигаем правую границу
                flag_find = True                                            # поднимаем флаг
            else:
                if searching_num < searched_array[middle]:                  # иначе, если искомое число располагается слева от середины поиска (то есть меньше)
                    right_edge = middle - 1                                 # сдвигаем правую границу поиска
                else:                                                       # иначе, если искомое число располагается справа от середины поиска (то есть больше)
                    left_edge = middle + 1                                  # сдвигаем левую границу поиска
        else:                                               # если совпадающий элемент уже нашли ранее
            if searching_num == searched_array[middle]:     # если элемент середины поиска является искомым
                right_edge = middle - 1                     # безопасно сдвигаем правую границу
            else:
                left_edge = middle + 1                      # безопасно сдвигаем правую границу
    return left_edge                                        # вылетим из цикла только тогда, когда левая граница будет больше правой (при этом она будет указывать на индекс первого элемента, совпадающего с искомым (либо больше его))



segments_numb, points_numb = (int(i) for i in input().split())      # считываем число отрезков и точек
# segments = []
# for i in range(segments_numb):
#     segments.append([int(i) for i in input().split()])
segments_left = []                                                  # список левых концов отрезков
segments_right = []                                                 # список правых концов отрезков
for i in range(segments_numb):                                      # для всех отрезков
    left, right = (int(j) for j in input().split())                 # считываем левый и правый концы
    segments_left.append(left)                                      # добавляем их в соответствующие массивы
    segments_right.append(right)
points = [int(i) for i in input().split()]                          # считываем точки


quick_sort(segments_left, 0, len(segments_left) - 1)                # сортируем список левых концов
quick_sort(segments_right, 0, len(segments_right) - 1)              # сортируем список правых концов
list_num_of_seg_for_p = []                                          # заводим лист ответов
dict_num_of_seg_for_p = {}                                          # заводим словарь точек
for point in points:                                                # для всех точек
    if point not in dict_num_of_seg_for_p:                          # если точки еще нет в словаре
        dict_num_of_seg_for_p[point] = binary_search_less_eq(segments_left, point, len(segments_left)) - binary_search_less(segments_right, point, len(segments_right))
        # добавляем запись о ней в словарь с ключом - значением точки и значением - количеством принадлежащих отрезков
        # при этом количество принадлежащих отрезков рассчитывается как (значение числа отрезков с началом меньше или равно точки - значение числа отрезков с концом меньше точки)

for point in points:                                                # для всех точек
    list_num_of_seg_for_p.append(dict_num_of_seg_for_p[point])      # формируем список ответов

print(*list_num_of_seg_for_p)                                       # выводим список ответов в строку



# print(segments_numb, points_numb)
# # for i in segments:
# #     print(i)
# # print(segments)
# print(segments_left)
# print(segments_right)
# print(points)



# unsort_len = int(input())
# unsort_array = list(map(int, input().split()))
# quick_sort(unsort_array, 0, unsort_len - 1)
# print(unsort_array)