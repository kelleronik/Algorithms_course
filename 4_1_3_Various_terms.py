# Данная программа вычисляет максимальное k различных натуральных слагаемых и сами эти слагаемые для введенного числа
# Вход: натуральное число n
# Выход: максимальное k различных натуральных слагаемых (число) и сами эти слагаемые (числа в строке)

# НАДЕЖНЫЙ ШАГ: начинать подбирать слагаемые с единицы, беря минимально возможные последовательные числа [1, 2, 3, ...] пока есть такая возможность

natural_inp = int(input())                  # исходное число

remain = natural_inp                        # остаток от исходного числа, будет уменьшаться с итерациями

iterator = 1                                # первоначальное значение итератора, который будет перебирать поо возможности [1, 2, 3, ...]

numbers = []                                # список различных натуральных слагаемых

# Решение основано на закономерности: 1:[1], 2:[2], 3:[1+2], 4:[1+3], 5:[1+4], 6:[1+2+3], 7:[1+2+4], 8:[1+2+5], 9:[1+2+6], 10:[1+2+3+4],
# 11:[1+2+3+5], 12:[1+2+3+6], 13:[1+2+3+7], 14:[1+2+3+8], 15:[1+2+3+4+5], 16:[1+2+3+4+6], 17:[1+2+3+4+7], 18:[1+2+3+4+8], 19:[1+2+3+4+9], 20:[1+2+3+4+10], 21:[1+2+3+4+5+6], 22:[1+2+3+4+5+8], и т.д.
# То есть, на примере 14: 14 = 1+2+3+8 - здесь 8 нельзя представить как сумму 1 + 2 + 3 так как они уже включены в список, и нельзя представить как 4 + 4 - так как это две четверки, поэтому берем само число 8
# и 15: 15 = 1+2+3+9  - здесь 9 можно представить как сумму 4 + 5, так как в списке таких чисел нет, поэтому 15 = 1+2+3+4+5

# Кроме того, при iterator = 3 (14:[1+2+'3'+8]): (iterator + 1) + (iterator + 2) = 2*iterator+3 = 9, а значит 15:[1+2+3+4+5]
# При iterator = 4 (20:[1+2+3+'4'+10]): (iterator + 1) + (iterator + 2) = 2*iterator+3 = 11, а значит 21:[1+2+3+4+5+6]

# Таким образом, все числа мы пытаемся представить как последовательность минимально возможных [1, 2, 3..., n, remain]
# При этом если (2*n+3)>remain, то remain нельзя расписать как (n+1)+(n+2): 9:[1+2+6] (при этом n = 2)
# Но если (2*n+3)=remain, то remain можно расписать как (n+1)+(n+2): 10:[1+2+3+4] (при этом n = 2)

while remain > 0:                           # Пока остаток не нулевой
    numbers.append(iterator)                # добавляем число в список
    remain = remain - iterator              # уменьшаем остаток
    if (remain < ((iterator + 1) + (iterator + 2))) and (remain > 0):   # Если остаток больше нуля, а также меньше суммы 2*iterator+3
        if remain > 1:                      # Случай, если мы не можем представить остаток, как неповторяющиеся натуральные числа меньше остатка
            numbers.append(remain) #if remain > 1 else numbers = [2]
        else:
            numbers = [2]                   # Случай, если на вход пришло число 2 (его не представить как 1+1 - повторение)
        break                               # Досрочно выходим из цикла
    else:
        iterator = iterator + 1             # Увеличиваем итератор на 1

print(len(numbers))
print(*numbers)