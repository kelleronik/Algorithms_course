# Программа сортирует входной массив по неубыванию а также выводит число инверсий в нем (меру неупорядоченности)
# Вход: размер массива n (число - строка) и сам массив (n чисел через пробел - строка)
# Выход: число инверсий (число)


# Функция слияния двух входящих массивов
def merge_arrays(array_left, array_right):              # получает на вход два массива
    inversions = 0                                      # начальное число инверсий массивов
    merged_array = []                                   # Слитый массив - сначала пустой
    left_counter = 0                                    # счетчик левого массива
    right_counter = 0                                   # счетчик правого массива
    while left_counter < len(array_left) and right_counter < len(array_right):    # пока оба счатчика не выше, чем индекс последнего элемента соответствующего массива
        if array_left[left_counter] <= array_right[right_counter]:                # если тукущий элемент левого массива меньше или равен текущего элемента правого
            merged_array.append(array_left[left_counter])                         # добавляем в слитый массив самый текущий левого
            left_counter += 1                                                     # увеличиваем счетчик левого массива на 1
        else:
            merged_array.append(array_right[right_counter])                       # добавляем в слитый массив текущий элемент правого
            right_counter += 1                                                    # увеличиваем счетчик правого массива на 1
            inversions += len(array_left) - left_counter                          # число инверсий увеличивается на оставшуюся длину левого (именно столько элементов левого массива больше того элемента, что только что был добавлен в слитый массив из правого)
    merged_array = merged_array + array_left[left_counter:] + array_right[right_counter:]   # дописываем слитый массив элементами левого или правого
    return merged_array, inversions                     # возвращаем слитый массив и число инверсий, которое было найдено при слиянии входных двух массивов

# Итеративная функция сортировки исходного массива - в данной функции на каждой итерации перебираются два последовательно идущих элемента массива, результат слияния их записывается в новый массив, затем старый массив заменяется на новый
def merge_sort(unsorted_array):                         # получает на вход несортированный массив
    inv_sum = 0                                         # Счетчик суммы инверсий
    part_sorted = []                                    # переменная для хранения отсортированной части
    for i in range(len(unsorted_array)):                # заменяем все числа-элементы массива на списки с числами (первоначально они будут длины 1)
        unsorted_array[i] = [unsorted_array[i]]
    while len(unsorted_array) > 1:                      # пока длина исходного массива больше единицы (то есть массив не до конца отсортирован, все элементы не слиты в один)
        for i in range(0, len(unsorted_array)-1, 2):    # попарно сортируем каждые идущие два подряд элемента (поэтому шаг 2)
            sorted_part, inv_curr = merge_arrays(unsorted_array[i], unsorted_array[i+1])    # сохраняем текущий отсортированный подмассив в переменную и число инверсий для него
            part_sorted.append(sorted_part)                                                 # добавляем переменную к отсуортированному списку текущего шага
            inv_sum += inv_curr                                                             # увеличиваем число инверсий
        if (len(unsorted_array) % 2) == 1:                                                  # если в массиве нечетное количество элементов, то добавляем к отсортированному списку последний элемент
            part_sorted.append(unsorted_array[-1])
        unsorted_array = part_sorted.copy()                                                 # заменяем исходный массив частично отсортированным
        part_sorted = []                                                                    # зануляем частично отсортированный массив

    return unsorted_array[0], inv_sum                                                       # возвращаем единственный элемент, оставшийся в исходном массиве (это и есть отсортированный массив), а также число инверсий


unsort_len = int(input())                                                               # принимаем длину массива
unsort_array = list(map(int, input().split()))                                          # принимаем сам несортированный массив
# unsort_array = [int(i) for i in input().split()]                                      # альтернативная версия записи исходного массива
unsort_array, sum_of_inversions = merge_sort(unsort_array)                              # перезаписываем массив и находим число инверсий

# print(unsort_array)
print(sum_of_inversions)                                                                # выводим число инверсий
